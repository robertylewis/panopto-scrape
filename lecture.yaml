lectures:
  - date: 9/4
    downloads: []
    # - name: Ch. 0 demo file
    # - notes: LoVe00_Preface.html
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe00_Preface_Demo.lean
    recording:
    - url: 3d8f2e23-26e0-43bd-ae0e-b1d9017e901f
    summary: |
      We'll talk about what Lean is and see what it can do, and also go over
      some organizational points about the course. <br><br> Takeaways: Verified programming
      is fun and powerful!
    topic: Introduction
  - date: 9/9
    downloads: []
    # - name: Ch. 1-2 demo file
    # - notes: LoVe01_02_TypesAndTerms_DemoMaster.html
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe01_02_TypesAndTerms_DemoMaster.lean
    recording:
    - url: 830f0056-4155-4260-9ee7-b1d9017e908c
    summary: |
      In this lecture we'll learn the basics of the Lean programming and specification
      language: types and terms, type inhabitation, and writing and evaluating very
      simple functional programs. No proving yet!"
    topic: The basics of Lean syntax
  - date: 9/11
    downloads: []
    # - name: Ch. 1-2 demo file
    # - notes: LoVe01_02_TypesAndTerms_DemoMaster.html
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe01_02_TypesAndTerms_DemoMaster.lean
    recording:
    - url: e9676188-7b6f-44b9-9ce2-b1d9017e90bd
    summary: |
      We'll finish Chapter 2 of the HHG, and get a head start on some material
      from Chapter 4. Today's topics: inductive types (continued), function definition
      and evaluation, specifications, and dependent type theory.
    topic: Dependent type theory
  - date: 9/16
    downloads: []
    # - name: Ch. 3 demo file
    # - notes: LoVe03_BackwardProofs_Demo.lean
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe03_BackwardProofs_Demo.lean
    recording:
    - url: 58e9441c-ac66-457f-8d46-b1d9017e90e3
    summary: |
      We'll dive into the meat of the HHG Ch. 3: what are some of the moves
      available to us in the tactic proving minigame, beyond <code>intro</code> and
      <code>apply</code>? How do we deal with logical connectives: <code>And</code>,
      <code>Or</code>, <code>Not</code>, and so on?
    topic: Backward (tactic) proofs
  - date: 9/18
    downloads: []
    # - name: Ch. 3 demo file
    # - notes: LoVe03_BackwardProofs_Demo.html
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe03_BackwardProofs_Demo.lean
    recording:
    - url: bc93d0ea-768a-4e67-ac2c-b1d9017e90f6
    summary: |
      We'll continue talking about tactic proofs. How do we deal with <i>equality</i>?
      What about the natural numbers? We'll also talk about <i>classical vs constructive</i>
      logic.
    topic: Backward (tactic) proofs, contd.
  - date: 9/23
    downloads: []
    # - name: Ch. 4 demo file
    # - notes: LoVe04_ForwardProofs_Demo.html
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe04_ForwardProofs_Demo.lean
    recording:
    - url: 8724ecdd-828f-4709-87e5-b1d9017e911d
    summary: |
      We'll see another way to write proofs in Lean, incorporating <i>forward
      reasoning</i>. Structured ("proof-term") proofs are a little closer to the underlying
      logic. Surprise: proofs in Lean are, literally, just terms in the type theory.
    topic: Forward proofs
  - date: 9/25
    downloads: []
    # - name: Ch. 4 demo file
    # - notes: LoVe04_ForwardProofs_Demo.html
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe04_ForwardProofs_Demo.lean
    recording:
    - url: 544addca-a1c6-4501-bdd6-b1d9017e913e
    summary: |
      We talked about dependent types before; now, more. The type theory that
      Lean is based on, the Calculus of Inductive Constructions, is an instance of dependent
      type theory. In DTT, we follow the PAT principle: propositions as types, proofs
      as terms. (Buzzword: the Curry-Howard correspondence!) We'll look deeper today
      into these foundations. Time permitting, we'll look at a few important algorithms,
      including <em>unification</em>.
    topic: Dependent types
  - date: 9/30
    downloads: []
    # - name: Ch. 5 demo file
    # - notes: LoVe05_FunctionalProgramming_Demo.html
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe05_FunctionalProgramming_Demo.lean
    recording:
    - url: d573472e-d0b3-4f40-8196-b1d9017e9165
    summary: |
      Chapter 5 of the Hitchhiker's Guide introduces some paradigms &mdash; inductive
      types, structures, recursive definitions, type classes &mdash; that might be familiar
      from other functional programming languages. The interesting thing for us is how
      these paradigms interact with writing proofs. For instance, how do we mix <i>properties</i>
      into <i>data structures</i>?
    topic: "Functional programming: data structures"
  - date: 10/2
    downloads: []
    # - name: Ch. 5 demo file
    # - notes: LoVe05_FunctionalProgramming_Demo.html
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe05_FunctionalProgramming_Demo.lean
    recording:
    - url: ae979d64-5872-4c12-bc8a-b1d9017e9189
    summary: |
      Type classes are a language feature inspired by Haskell with equivalents
      in Scala, ML, and other languages. They allow us a kind of <i>ad hoc polymorphism</i>:
      we can define functions on types that implement certain interfaces, and can declare
      that certain types implement these interfaces, without bundling the interfaces
      into the data type itself. we'll see how this interacts with some of the data
      structures we like to use, as we implement and specify functions on these types.
    topic: "Functional programming: type classes, lists, trees"
  - date: 10/7
    downloads: []
    # - name: Ch. 6 demo file
    # - notes: LoVe06_InductivePredicates_Demo.html
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe06_InductivePredicates_Demo.lean
    recording:
    - url: ce217923-3d54-4343-98f5-b1d9017e91ae
    summary: |
      We'll cover ch. 6 of the Hitchhiker's Guide today, on inductive predicates.
      This will complete what we need to know about foundations for now: inductive predicates
      give us a way to introduce new propositions and prove things about them. Inductive
      predicates are also the source of most of the propositional symbols we've used
      so far &mdash; <code>And</code>, <code>Or</code>, <code>Exists</code>, <code>Eq</code>,
      &hellip;.
    topic: Inductive predicates
  - date: 10/9
    downloads: []
    # - name: Ch. 9 demo file
    # - notes: LoVe09_OperationalSemantics_Demo.html
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe09_OperationalSemantics_Demo.lean
    recording:
    - url: 898d6a1e-568d-4826-87aa-b1d9017e91cf
    summary: |
      We're jumping ahead to Chapter 9 today! Time to start putting what we've
      learned into practice. We'll define the syntax of a toy programming language inside
      of Lean, discussing the difference between shallow and deep embeddings. Using
      inductive predicates, we'll define a transition system and use this to prove things
      about the execution of programs in this toy language.
    topic: Big-step operational semantics
  - date: 10/16
    downloads: []
    # - name: Ch. 9 demo file
    # - notes: LoVe09_OperationalSemantics_Demo.html
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe09_OperationalSemantics_Demo.lean
    recording:
    - url: bdaffebb-cb06-4ee7-bcec-b1d9017e9216
    summary: |
      The big-step semantics we saw on Monday aren't fine-grained. We can't reason
      about intermediate states. An alternative is using a small-step semantics, where
      our program execution path is broken down much further. This comes with upsides
      and downsides.
    topic: Small-step operational semantics
  - date: 10/21
    downloads: []
    # - name: Ch. XX demo file
    # - notes: LoVeXX_ALookUnderTheHood_Demo.html
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVeXX_ALookUnderTheHood_Demo.lean
    recording:
    - url: 2f8fa9a9-8f50-4eab-8b68-b1d9017e923c
    summary: |
      We'll talk theory today, about the data structures and process flow that
      underlie a proof assistant. Basically, we'll think about Lean as a programming
      language in the sense of the last two lectures. What's its syntax? What are its
      <em>semantics</em>??
    topic: A look under the hood
  - date: 10/23
    downloads: []
    # - name: Ch. 12 demo file
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe12_LogicalFoundationsOfMathematics_Demo.lean
    # - name: Russellian paradox demo
    # - notes: LoVe12_LogicalFoundationsOfMathematics_Demo.html
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe12_Russell.lean
    recording:
    - url: 3128c104-57cb-440e-b7af-b1d9017e925d
    summary: |
      As this course has progressed, we've gotten some insight into the foundations
      of Lean and its type theory. But some features have remained mysterious. In the
      next few lectures we'll poke some more at this foundational theory. Today we'll
      be focusing in particular on the type universe <code>Prop</code>, what we're allowed
      and disallowed in this universe compared to the others.
    topic: Logical foundations
  - date: 10/28
    downloads: []
    # - name: Ch. 13 demo file
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe13_BasicMathematicalStructures_Demo.lean
    # - name: Complex numbers playground
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/Complex.lean
    recording:
    - url: 4ca02170-13c6-4520-aa31-b1d9017e927a
    summary: |
      We'll jump ahead again to chapter 13, where we'll start talking about algebraic
      structures. But we'll also improvise a bit here. After we see some basic structures,
      we'll define some mathematical types of our own.
    topic: Algebraic structures
  - date: 10/30
    downloads: []
    # - name: Ch. 13 demo file
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe13_BasicMathematicalStructures_Demo.lean
    # - name: Complex numbers playground
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/Complex.lean
    recording:
    - url: e7d44c69-bbe1-42f7-b8a5-b1d9017e9297
    summary: |
      We'll continue the Ch 13 material we started last time, including a little
      more with the complex number playground. We'll also talk about embeddings between
      different numerical structures, and some different kinds of "set-like" objects.
    topic: Numbers and sets
  - date: 11/4
    downloads: []
    # - name: Ch. 12 demo file
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe12_LogicalFoundationsOfMathematics_Demo.lean
    # - name: Ch. 13 demo file
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe13_BasicMathematicalStructures_Demo.lean
    # - name: Complex numbers playground
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/Complex.lean
    recording:
    - url: 76b3b469-92ef-4c5a-8890-b1d9017e92af
    summary: |
      We'll continue with chapter 12 today, talking about more foundational
      constructs. As we discussed last class, there's a grab bag of features that we
      can take or leave: proof irrelevance, impredicative Prop, the axiom of choice,
      and others. Why should we be convinced that the collection we choose is consistent?
      We'll introduce the notion of a model of the type theory to answer questions
      like this.
    topic: Logical foundations, contd.
  - date: 11/6
    downloads: []
    # - name: Ch. 12 demo file
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe12_LogicalFoundationsOfMathematics_Demo.lean
    # - name: Ch. 14 demo file
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe14_RationalAndRealNumbers_Demo.lean
    recording:
    - url: a1b92949-ad09-4342-b08c-b1d9017e92cd
    summary: |
      The last bit of Ch. 12, on quotient types, is very relevant to what we
      want to do next! We'll wrap up that discussion (including talking a bit about
      the computability properties of quotients) and then immediately use quotient types
      to define some familiar things. Rational and real numbers are interesting mathematically,
      and for programming purposes, they can be a very convenient tool for writing specifications.
      Even if we don't compute with real numbers they're useful to have around.
    topic: Quotients, rationals, and reals
  - date: 11/11
    downloads: []
    # - name: Ch. 14 demo file
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe14_RationalAndRealNumbers_Demo.lean
    recording:
    - url: 2bdabda3-a94a-4aea-846d-b1d9017e92e9
    summary: |
      We finished last week with the rational numbers. Now we need to complete
      them to get the reals. This will take yet another quotient. The reals bring to
      light some computability issues that we've touched on briefly before: what does
      it mean to compute with real numbers? How do we do it in normal languages? If
      time permits, we'll look at mathlib's implementation of the reals and see some
      generalizations.
    topic: Real numbers
  - date: 11/13
    downloads: []
    # - name: Ch. 7 demo file
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe07_EffectfulProgramming_Demo.lean
    recording:
    - url: aed55ac0-7521-4d2a-8252-b1d9017e930a
    summary: |
      Lean has a very powerful framework for writing custom tactics.
      These tactics are written in Lean itself, with a number of catches to make
      this possible. Today we'll see the fundamentals of this approach. We'll
      learn the (very) basics about monads, a technique used in some functional
      languages to simulate programming with side effects. (But this isn't an FP
      class and we're not going to dwell on monads, beyond what we need to know.)
      Chapter 7 of the HHG is a more detailed introduction to monads.
    topic: Monads and tactics
  - date: 11/18
    downloads: []
    # - name: Ch. 8 demo file
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe08_Metaprogramming_Demo.lean
    recording:
    - url: 8e9a9bee-65a6-4cb1-926f-b1d9017e9327
    summary: |
      More from chapters 7 and 8 of the HHG. We'll look at <em>macros</em>, a simple kind of metaprogram.
      Then we'll turn our attention to the <code>TacticM</code> monad, which provides an API for interacting
      with our context and goals.
    topic: Monads and tactics
  - date: 11/20
    downloads: []
    # - name: Ch. 8 demo file
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe08_Metaprogramming_Demo.lean
    recording:
    - url: c9970e94-dbfa-42b3-918a-b1d9017e934e
    summary: |
      We'll continue our discussion of metaprogramming by implementing a few custom tactics. Along the way,
      we'll see some more metaprogramming techniques and a few "imperative-like" features of monads that make
      our lives easier when writing tactics.
    topic: Monads and tactics
  - date: 11/25
    downloads: []
    # - name: Ch. 8 demo file
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/LoVe08_Metaprogramming_Demo.lean
    recording:
    - url: de2f026f-927b-4a07-ab54-b1d9017e936b
    summary: |
      Metaprogramming TBD
    topic: Monads and tactics
  - date: 12/2
    downloads: []
    recording:
    - url: c0cc0d8b-5203-4c4d-8b5e-b1d9017e93a9
    summary: ""
    topic: Guest lecture TBD
  - date: 12/4
    downloads: []
    # - name: Tactic strategies demo file
    # - notes: TacticStrategies.html
    # url: https://github.com/BrownCS1951x/fpv2024/blob/main/LoVe/Lectures/TacticStrategies.lean
    recording:
    - url: 0cc52d03-8382-459e-a9df-b1d9017e93d9
    summary: |
      The tactics we've seen so far manipulate the tactic state in stages.
      Today we'll consider some high level designs for automation: proof by certificate
      and proof by reflection. We'll also talk about the strategy and algorithm behind
      the tactic <code>linarith</code>, a great example of a "large" metaprogram
      that shows off a number of interesting design principles.
    topic: Tactic design strategies
